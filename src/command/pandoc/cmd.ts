/*
* pandoc.ts
*
* Copyright (C) 2020-2024 Posit Software, PBC
*
*/
import { join } from "../../deno_ral/path.ts";

import { Command, Option } from "npm:clipanion";
import { execProcess } from "../../core/process.ts";
import { pandocBinaryPath } from "../../core/resources.ts";

export class PandocCommand extends Command {
  static name = 'pandoc';
  static paths = [[PandocCommand.name]];

  static usage = Command.Usage({
    description: "Run the version of Pandoc embedded within Quarto.\n" +
        "You can pass arbitrary command line arguments to quarto pandoc\n" +
        "(they will be passed through unmodified to Pandoc)",
  })

  args = Option.Proxy();

  async runPandoc(options = {}) {
    const { env } = this.context;
    return await execProcess(
        {
          cmd: [pandocBinaryPath(), ...this.args],
          env: (env as Record<string, string>),
          ...options,
        },
        undefined,
        undefined,
        undefined,
        true,
    );
  }

  async execute() {
    const result = await this.runPandoc();
    Deno.exit(result.code);
  }
}

interface WrappedProperty {
    property: string;
    formatter: string;
}

const ignoredPandocOptions = [
    // help and version flags are provided by clipanion
    '--help',
    '--version',

    // parsed by Quarto and injected later
    "--metadata",
    "--metadata-file",

    // handled by appendLogOptions()
    "--log",

    // injected from RenderFlags
    "--quiet",
];

const createWrapperProperty = (pandocArgLine: string[]): WrappedProperty | null => {
    // short options such as -s[true|false] cannot be parsed by clipanion
    const supportedOptions = pandocArgLine.filter(option => !option.includes('[true|false]'));
    if (supportedOptions.length === 0) {
        return null;
    }

    const optionNames = supportedOptions.map(flag => flag.split(/[ =[]/)[0]);
    const longOptionName = optionNames.find(option => option.startsWith('--'))!;

    if (ignoredPandocOptions.includes(longOptionName)) {
        return null;
    }

    const propertyName = longOptionName.replace(/^--/, '');

    const withoutParameter = !supportedOptions.some(option => option.includes('='));
    if (withoutParameter) {
        return {
            property: `['${propertyName}'] = Option.Boolean('${optionNames.join(',')}', { hidden: true });`,
            formatter: `formatBooleanOption('${longOptionName}', this['${propertyName}'])`,
        }
    }

    const optionConfig = ['hidden: true'];

    // handle special cases first
    if (propertyName === 'number-offset') {
        optionConfig.push('validator: isArray(isNumber())');
        return {
            property: `['${propertyName}'] = Option.Array('${optionNames.join(',')}', { ${optionConfig.join(', ')} });`,
            formatter: `formatArrayOption('${longOptionName}', this['${propertyName}'])`,
        }
    }

    if (propertyName === 'pdf-engine-opt') {
        return {
            property: `['${propertyName}'] = Option.Array('${optionNames.join(',')}', { ${optionConfig.join(', ')} });`,
            formatter: `formatArrayOption('${longOptionName}', this['${propertyName}'])`,
        }
    }

    const booleanParameter = supportedOptions.some(option => option.includes('[=true|false]'));
    const numberParameter = supportedOptions.some(option => option.includes('=NUMBER'));
    const optionalParameter = supportedOptions.some(option => option.includes('[='));
    if (booleanParameter) {
        optionConfig.push('tolerateBoolean: true');
        optionConfig.push('validator: isBoolean()');
    } else  if (numberParameter) {
        optionConfig.push('validator: isNumber()');
    }
    else if (optionalParameter) {
        optionConfig.push('tolerateBoolean: true');
    }

    return {
        property: `['${propertyName}'] = Option.String('${optionNames.join(',')}', { ${optionConfig.join(', ')} });`,
        formatter: `formatStringOption('${longOptionName}', this['${propertyName}'])`,
    };
}

export class GeneratePandocWrapperCommand extends PandocCommand {
    static paths = [['generate-pandoc-wrapper']];

    static usage = Command.Usage({
        category: 'internal',
        description: "Produce class wrapping the Pandoc command line arguments.",
    })

    args = ['--help'];

    async execute() {
        const {stdout} = await this.runPandoc({ stdout: "null" });

        const pandocArgs = stdout!.trimEnd()
            .split('\n')
            .splice(1)
            .map(line =>
                line.trim()
                    .replaceAll(', ', '  ')
                    .split(/ {2,}/)
            );

        const wrappedProperties = pandocArgs.map(createWrapperProperty).filter(Boolean) as WrappedProperty[];
        const output = `
// generated by quarto generate-pandoc-wrapper

import { Command, Option } from "npm:clipanion";
import { isArray, isBoolean, isNumber } from "npm:typanion";
import { formatArrayOption, formatBooleanOption, formatStringOption } from "./formatters.ts";

export abstract class PandocWrapperCommand extends Command {
  ${wrappedProperties.map(({ property }) => property).join('\n  ')}
  
  get formattedPandocArgs(): string[] {
    return [
      ${wrappedProperties.map(({ formatter }) => formatter).join(',\n      ')}
    ].filter(Boolean) as string[];
  }
}
        `;
        const tempFilePath = await Deno.makeTempFile();
        await Deno.writeTextFile(tempFilePath, output.trim() + '\n');

        const outputFilePath = join(import.meta.dirname!, 'wrapper.ts');
        await Deno.rename(tempFilePath, outputFilePath);
    }
}