{
  "version": 3,
  "sources": ["../../../srcts/src/components/_utils.ts", "../../../srcts/src/components/accordion.ts", "../../../srcts/src/components/_shinyResizeObserver.ts", "../../../srcts/src/components/card.ts", "../../../srcts/src/components/sidebar.ts", "../../../srcts/src/components/_shinyAddCustomMessageHandlers.ts", "../../../srcts/src/components/index.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  // Cross-referenced with https://allyjs.io/data-tables/focusable.html\n  const base = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button\",\n    \"details summary\",\n    \"input\",\n    \"iframe\",\n    \"select\",\n    \"textarea\",\n    '[contentEditable=\"\"]',\n    '[contentEditable=\"true\"]',\n    '[contentEditable=\"TRUE\"]',\n    \"[tabindex]\",\n  ];\n  const modifiers = [':not([tabindex=\"-1\"])', \":not([disabled])\"];\n  const selectors = base.map((b) => b + modifiers.join(\"\"));\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n};\nexport type { HtmlDep };\n", "import type { HtmlDep } from \"./_utils\";\nimport { InputBinding, registerBinding, hasDefinedProperty } from \"./_utils\";\n\ntype AccordionItem = {\n  item: HTMLElement;\n  value: string;\n  isOpen: () => boolean;\n  show: () => void;\n  hide: () => void;\n};\n\ntype HTMLContent = {\n  html: string;\n  deps?: HtmlDep[];\n};\n\ntype SetMessage = {\n  method: \"set\";\n  values: string[];\n};\n\ntype OpenMessage = {\n  method: \"open\";\n  values: string[] | true;\n};\n\ntype CloseMessage = {\n  method: \"close\";\n  values: string[] | true;\n};\n\ntype InsertMessage = {\n  method: \"insert\";\n  panel: HTMLContent;\n  target: string;\n  position: \"after\" | \"before\";\n};\n\ntype RemoveMessage = {\n  method: \"remove\";\n  target: string[];\n};\n\ntype UpdateMessage = {\n  method: \"update\";\n  target: string;\n  value: string;\n  body: HTMLContent;\n  title: HTMLContent;\n  icon: HTMLContent;\n};\n\ntype MessageData =\n  | CloseMessage\n  | InsertMessage\n  | OpenMessage\n  | RemoveMessage\n  | SetMessage\n  | UpdateMessage;\n\nclass AccordionInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(\".accordion.bslib-accordion-input\");\n  }\n\n  getValue(el: HTMLElement): string[] | null {\n    const items = this._getItemInfo(el);\n    const selected = items.filter((x) => x.isOpen()).map((x) => x.value);\n    return selected.length === 0 ? null : selected;\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"shown.bs.collapse.accordionInputBinding hidden.bs.collapse.accordionInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".accordionInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: MessageData) {\n    const method = data.method;\n    if (method === \"set\") {\n      this._setItems(el, data);\n    } else if (method === \"open\") {\n      this._openItems(el, data);\n    } else if (method === \"close\") {\n      this._closeItems(el, data);\n    } else if (method === \"remove\") {\n      this._removeItem(el, data);\n    } else if (method === \"insert\") {\n      this._insertItem(el, data);\n    } else if (method === \"update\") {\n      this._updateItem(el, data);\n    } else {\n      throw new Error(`Method not yet implemented: ${method}`);\n    }\n  }\n\n  protected _setItems(el: HTMLElement, data: SetMessage) {\n    const items = this._getItemInfo(el);\n    const vals = this._getValues(el, items, data.values);\n    items.forEach((x) => {\n      vals.indexOf(x.value) > -1 ? x.show() : x.hide();\n    });\n  }\n\n  protected _openItems(el: HTMLElement, data: OpenMessage) {\n    const items = this._getItemInfo(el);\n    const vals = this._getValues(el, items, data.values);\n    items.forEach((x) => {\n      if (vals.indexOf(x.value) > -1) x.show();\n    });\n  }\n\n  protected _closeItems(el: HTMLElement, data: CloseMessage) {\n    const items = this._getItemInfo(el);\n    const vals = this._getValues(el, items, data.values);\n    items.forEach((x) => {\n      if (vals.indexOf(x.value) > -1) x.hide();\n    });\n  }\n\n  protected _insertItem(el: HTMLElement, data: InsertMessage) {\n    let targetItem = this._findItem(el, data.target);\n\n    // If no target was specified, or the target was not found, then default\n    // to the first or last item, depending on the position\n    if (!targetItem) {\n      targetItem = (\n        data.position === \"before\" ? el.firstElementChild : el.lastElementChild\n      ) as HTMLElement;\n    }\n\n    const panel = data.panel;\n\n    // If there is still no targetItem, then there are no items in the accordion\n    if (targetItem) {\n      Shiny.renderContent(\n        targetItem,\n        panel,\n        data.position === \"before\" ? \"beforeBegin\" : \"afterEnd\"\n      );\n    } else {\n      Shiny.renderContent(el, panel);\n    }\n\n    // Need to add a reference to the parent id that makes autoclose to work\n    if (this._isAutoClosing(el)) {\n      const val = $(panel.html).attr(\"data-value\");\n      $(el)\n        .find(`[data-value=\"${val}\"] .accordion-collapse`)\n        .attr(\"data-bs-parent\", \"#\" + el.id);\n    }\n  }\n\n  protected _removeItem(el: HTMLElement, data: RemoveMessage) {\n    const targetItems = this._getItemInfo(el).filter(\n      (x) => data.target.indexOf(x.value) > -1\n    );\n\n    const unbindAll = Shiny?.unbindAll;\n\n    targetItems.forEach((x) => {\n      if (unbindAll) unbindAll(x.item);\n      x.item.remove();\n    });\n  }\n\n  protected _updateItem(el: HTMLElement, data: UpdateMessage) {\n    const target = this._findItem(el, data.target);\n\n    if (!target) {\n      throw new Error(\n        `Unable to find an accordion_panel() with a value of ${data.target}`\n      );\n    }\n\n    if (hasDefinedProperty(data, \"value\")) {\n      target.dataset.value = data.value;\n    }\n\n    if (hasDefinedProperty(data, \"body\")) {\n      const body = target.querySelector(\".accordion-body\") as HTMLElement; // always exists\n      Shiny.renderContent(body, data.body);\n    }\n\n    const header = target.querySelector(\".accordion-header\") as HTMLElement; // always exists\n\n    if (hasDefinedProperty(data, \"title\")) {\n      const title = header.querySelector(\".accordion-title\") as HTMLElement; // always exists\n      Shiny.renderContent(title, data.title);\n    }\n\n    if (hasDefinedProperty(data, \"icon\")) {\n      const icon = header.querySelector(\n        \".accordion-button > .accordion-icon\"\n      ) as HTMLElement; // always exists\n      Shiny.renderContent(icon, data.icon);\n    }\n  }\n\n  protected _getItemInfo(el: HTMLElement): AccordionItem[] {\n    const items = Array.from(\n      el.querySelectorAll(\":scope > .accordion-item\")\n    ) as HTMLElement[];\n    return items.map((x) => this._getSingleItemInfo(x));\n  }\n\n  protected _getSingleItemInfo(x: HTMLElement): AccordionItem {\n    const collapse = x.querySelector(\".accordion-collapse\") as HTMLElement;\n    const isOpen = () => $(collapse).hasClass(\"show\");\n    return {\n      item: x,\n      value: x.dataset.value as string,\n      isOpen: isOpen,\n      show: () => {\n        if (!isOpen()) $(collapse).collapse(\"show\");\n      },\n      hide: () => {\n        if (isOpen()) $(collapse).collapse(\"hide\");\n      },\n    };\n  }\n\n  protected _getValues(\n    el: HTMLElement,\n    items: AccordionItem[],\n    values: string[] | true\n  ): string[] {\n    let vals = values !== true ? values : items.map((x) => x.value);\n    const autoclose = this._isAutoClosing(el);\n    if (autoclose) {\n      vals = vals.slice(vals.length - 1, vals.length);\n    }\n    return vals;\n  }\n\n  protected _findItem(el: HTMLElement, value: string): HTMLElement | null {\n    return el.querySelector(`[data-value=\"${value}\"]`);\n  }\n\n  protected _isAutoClosing(el: HTMLElement): boolean {\n    return el.classList.contains(\"autoclose\");\n  }\n}\n\nregisterBinding(AccordionInputBinding, \"accordion\");\n", "/**\n * A resize observer that ensures Shiny outputs resize during or just after\n * their parent container size changes. Useful, in particular, for sidebar\n * transitions or for full-screen card transitions.\n *\n * @class ShinyResizeObserver\n * @typedef {ShinyResizeObserver}\n */\nclass ShinyResizeObserver {\n  /**\n   * The actual ResizeObserver instance.\n   * @private\n   * @type {ResizeObserver}\n   */\n  private resizeObserver: ResizeObserver;\n  /**\n   * An array of elements that are currently being watched by the Resize\n   * Observer.\n   *\n   * @details\n   * We don't currently have lifecycle hooks that allow us to unobserve elements\n   * when they are removed from the DOM. As a result, we need to manually check\n   * that the elements we're watching still exist in the DOM. This array keeps\n   * track of the elements we're watching so that we can check them later.\n   * @private\n   * @type {HTMLElement[]}\n   */\n  private resizeObserverEntries: HTMLElement[];\n\n  /**\n   * Watch containers for size changes and ensure that Shiny outputs and\n   * htmlwidgets within resize appropriately.\n   *\n   * @details\n   * The ShinyResizeObserver is used to watch the containers, such as Sidebars\n   * and Cards for size changes, in particular when the sidebar state is toggled\n   * or the card body is expanded full screen. It performs two primary tasks:\n   *\n   * 1. Dispatches a `resize` event on the window object. This is necessary to\n   *    ensure that Shiny outputs resize appropriately. In general, the window\n   *    resizing is throttled and the output update occurs when the transition\n   *    is complete.\n   * 2. If an output with a resize method on the output binding is detected, we\n   *    directly call the `.onResize()` method of the binding. This ensures that\n   *    htmlwidgets transition smoothly. In static mode, htmlwidgets does this\n   *    already.\n   *\n   * @note\n   * This resize observer also handles race conditions in some complex\n   * fill-based layouts with multiple outputs (e.g., plotly), where shiny\n   * initializes with the correct sizing, but in-between the 1st and last\n   * renderValue(), the size of the output containers can change, meaning every\n   * output but the 1st gets initialized with the wrong size during their\n   * renderValue(). Then, after the render phase, shiny won't know to trigger a\n   * resize since all the widgets will return to their original size (and thus,\n   * Shiny thinks there isn't any resizing to do). The resize observer works\n   * around this by ensuring that the output is resized whenever its container\n   * size changes.\n   * @constructor\n   */\n  constructor() {\n    this.resizeObserverEntries = [];\n    this.resizeObserver = new ResizeObserver((entries) => {\n      const resizeEvent = new Event(\"resize\");\n      window.dispatchEvent(resizeEvent);\n\n      // the rest of this callback is only relevant in Shiny apps\n      if (!window.Shiny) return;\n\n      const resized = [] as HTMLElement[];\n\n      for (const entry of entries) {\n        if (!(entry.target instanceof HTMLElement)) continue;\n        if (!entry.target.querySelector(\".shiny-bound-output\")) continue;\n\n        entry.target\n          .querySelectorAll<HTMLElement>(\".shiny-bound-output\")\n          .forEach((el) => {\n            if (resized.includes(el)) return;\n\n            const { binding, onResize } = $(el).data(\"shinyOutputBinding\");\n            if (!binding || !binding.resize) return;\n\n            // if this output is owned by another observer, skip it\n            const owner = (el as any).shinyResizeObserver;\n            if (owner && owner !== this) return;\n            // mark this output as owned by this shinyResizeObserver instance\n            if (!owner) (el as any).shinyResizeObserver = this;\n\n            // trigger immediate resizing of outputs with a resize method\n            onResize(el);\n            // only once per output and resize event\n            resized.push(el);\n\n            // set plot images to 100% width temporarily during the transition\n            if (!el.classList.contains(\"shiny-plot-output\")) return;\n            const img = el.querySelector<HTMLImageElement>(\n              'img:not([width=\"100%\"])'\n            );\n            if (img) img.setAttribute(\"width\", \"100%\");\n          });\n      }\n    });\n  }\n\n  /**\n   * Observe an element for size changes.\n   * @param {HTMLElement} el - The element to observe.\n   */\n  observe(el: HTMLElement): void {\n    this.resizeObserver.observe(el);\n    this.resizeObserverEntries.push(el);\n  }\n\n  /**\n   * Stop observing an element for size changes.\n   * @param {HTMLElement} el - The element to stop observing.\n   */\n  unobserve(el: HTMLElement): void {\n    const idxEl = this.resizeObserverEntries.indexOf(el);\n    if (idxEl < 0) return;\n\n    this.resizeObserver.unobserve(el);\n    this.resizeObserverEntries.splice(idxEl, 1);\n  }\n\n  /**\n   * This method checks that we're not continuing to watch elements that no\n   * longer exist in the DOM. If any are found, we stop observing them and\n   * remove them from our array of observed elements.\n   *\n   * @private\n   * @static\n   */\n  flush(): void {\n    this.resizeObserverEntries.forEach((el) => {\n      if (!document.body.contains(el)) this.unobserve(el);\n    });\n  }\n}\n\nexport { ShinyResizeObserver };\n", "import { getAllFocusableChildren } from \"./_utils\";\nimport { ShinyResizeObserver } from \"./_shinyResizeObserver\";\n\n/**\n * The overlay element that is placed behind the card when expanded full screen.\n *\n * @interface CardFullScreenOverlay\n * @typedef {CardFullScreenOverlay}\n */\ninterface CardFullScreenOverlay {\n  /**\n   * The full screen overlay container.\n   * @type {HTMLDivElement}\n   */\n  container: HTMLDivElement;\n  /**\n   * The anchor element used to close the full screen overlay.\n   * @type {HTMLAnchorElement}\n   */\n  anchor: HTMLAnchorElement;\n}\n\n/**\n * The bslib card component class.\n *\n * @class Card\n * @typedef {Card}\n */\nclass Card {\n  /**\n   * The card container element.\n   * @private\n   * @type {HTMLElement}\n   */\n  private card: HTMLElement;\n  /**\n   * The card's full screen overlay element. We create this element once and add\n   * and remove it from the DOM as needed (this simplifies focus management\n   * while in full screen mode).\n   * @private\n   * @type {CardFullScreenOverlay}\n   */\n  private overlay: CardFullScreenOverlay;\n\n  /**\n   * Key bslib-specific classes and attributes used by the card component.\n   * @private\n   * @static\n   * @type {{ ATTR_INIT: string; CLASS_CARD: string; CLASS_FULL_SCREEN: string; CLASS_HAS_FULL_SCREEN: string; CLASS_FULL_SCREEN_ENTER: string; CLASS_FULL_SCREEN_EXIT: string; ID_FULL_SCREEN_OVERLAY: string; }}\n   */\n  private static attr = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ATTR_INIT: \"data-bslib-card-init\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_CARD: \"bslib-card\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ATTR_FULL_SCREEN: \"data-full-screen\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_HAS_FULL_SCREEN: \"bslib-has-full-screen\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_FULL_SCREEN_ENTER: \"bslib-full-screen-enter\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_FULL_SCREEN_EXIT: \"bslib-full-screen-exit\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ID_FULL_SCREEN_OVERLAY: \"bslib-full-screen-overlay\",\n  };\n\n  /**\n   * A Shiny-specific resize observer that ensures Shiny outputs in within the\n   * card resize appropriately.\n   * @private\n   * @type {ShinyResizeObserver}\n   * @static\n   */\n  private static shinyResizeObserver = new ShinyResizeObserver();\n\n  /**\n   * Creates an instance of a bslib Card component.\n   *\n   * @constructor\n   * @param {HTMLElement} card\n   */\n  constructor(card: HTMLElement) {\n    // remove initialization attribute and script\n    card.removeAttribute(Card.attr.ATTR_INIT);\n    card\n      .querySelector<HTMLScriptElement>(`script[${Card.attr.ATTR_INIT}]`)\n      ?.remove();\n\n    this.card = card;\n    Card.instanceMap.set(card, this);\n\n    // Let Shiny know to trigger resize when the card size changes\n    // TODO: shiny could/should do this itself (rstudio/shiny#3682)\n    Card.shinyResizeObserver.observe(this.card);\n\n    this._addEventListeners();\n    this.overlay = this._createOverlay();\n\n    // bind event handler methods to this card instance\n    this._exitFullScreenOnEscape = this._exitFullScreenOnEscape.bind(this);\n    this._trapFocusExit = this._trapFocusExit.bind(this);\n  }\n\n  /**\n   * Enter the card's full screen mode, either programmatically or via an event\n   * handler. Full screen mode is activated by adding a class to the card that\n   * positions it absolutely and expands it to fill the viewport. In addition,\n   * we add a full screen overlay element behind the card and we trap focus in\n   * the expanded card while in full screen mode.\n   *\n   * @param {?Event} [event]\n   */\n  enterFullScreen(event?: Event): void {\n    if (event) event.preventDefault();\n\n    document.addEventListener(\"keydown\", this._exitFullScreenOnEscape, false);\n\n    // trap focus in the fullscreen container, listening for Tab key on the\n    // capture phase so we have the best chance of preventing other handlers\n    document.addEventListener(\"keydown\", this._trapFocusExit, true);\n\n    this.card.setAttribute(Card.attr.ATTR_FULL_SCREEN, \"true\");\n    document.body.classList.add(Card.attr.CLASS_HAS_FULL_SCREEN);\n    this.card.insertAdjacentElement(\"beforebegin\", this.overlay.container);\n\n    // Set initial focus on the card, if not already\n    if (\n      !this.card.contains(document.activeElement) ||\n      document.activeElement?.classList.contains(\n        Card.attr.CLASS_FULL_SCREEN_ENTER\n      )\n    ) {\n      this.card.setAttribute(\"tabindex\", \"-1\");\n      this.card.focus();\n    }\n  }\n\n  /**\n   * Exit full screen mode. This removes the full screen overlay element,\n   * removes the full screen class from the card, and removes the keyboard event\n   * listeners that were added when entering full screen mode.\n   */\n  exitFullScreen(): void {\n    document.removeEventListener(\n      \"keydown\",\n      this._exitFullScreenOnEscape,\n      false\n    );\n    document.removeEventListener(\"keydown\", this._trapFocusExit, true);\n\n    // Remove overlay and remove full screen classes from card\n    this.overlay.container.remove();\n    this.card.setAttribute(Card.attr.ATTR_FULL_SCREEN, \"false\");\n    this.card.removeAttribute(\"tabindex\");\n    document.body.classList.remove(Card.attr.CLASS_HAS_FULL_SCREEN);\n  }\n\n  /**\n   * Adds general card-specific event listeners.\n   * @private\n   */\n  private _addEventListeners(): void {\n    const btnFullScreen = this.card.querySelector(\n      `:scope > * > .${Card.attr.CLASS_FULL_SCREEN_ENTER}`\n    );\n    if (!btnFullScreen) return;\n    btnFullScreen.addEventListener(\"click\", (ev) => this.enterFullScreen(ev));\n  }\n\n  /**\n   * An event handler to exit full screen mode when the Escape key is pressed.\n   * @private\n   * @param {KeyboardEvent} event\n   */\n  private _exitFullScreenOnEscape(event: KeyboardEvent): void {\n    if (!(event.target instanceof HTMLElement)) return;\n    // If the user is in the middle of a select input choice, don't exit\n    const selOpenSelectInput = [\"select[open]\", \"input[aria-expanded='true']\"];\n    if (event.target.matches(selOpenSelectInput.join(\", \"))) return;\n\n    if (event.key === \"Escape\") {\n      this.exitFullScreen();\n    }\n  }\n\n  /**\n   * An event handler to trap focus within the card when in full screen mode.\n   *\n   * @description\n   * This keyboard event handler ensures that tab focus stays within the card\n   * when in full screen mode. When the card is first expanded,\n   * we move focus to the card element itself. If focus somehow leaves the card,\n   * we returns focus to the card container.\n   *\n   * Within the card, we handle only tabbing from the close anchor or the last\n   * focusable element and only when tab focus would have otherwise left the\n   * card. In those cases, we cycle focus to the last focusable element or back\n   * to the anchor. If the card doesn't have any focusable elements, we move\n   * focus to the close anchor.\n   *\n   * @note\n   * Because the card contents may change, we check for focusable elements\n   * every time the handler is called.\n   *\n   * @private\n   * @param {KeyboardEvent} event\n   */\n  private _trapFocusExit(event: KeyboardEvent): void {\n    if (!(event instanceof KeyboardEvent)) return;\n    if (event.key !== \"Tab\") return;\n\n    const isFocusedContainer = event.target === this.card;\n    const isFocusedAnchor = event.target === this.overlay.anchor;\n    const isFocusedWithin = this.card.contains(event.target as Node);\n\n    const stopEvent = () => {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    };\n\n    if (!(isFocusedWithin || isFocusedContainer || isFocusedAnchor)) {\n      // If focus is outside the card, return to the card\n      stopEvent();\n      this.card.focus();\n      return;\n    }\n\n    // Check focusables every time because the card contents may have changed\n    // but exclude the full screen enter button from this list of elements\n    const focusableElements = getAllFocusableChildren(this.card).filter(\n      (el) => !el.classList.contains(Card.attr.CLASS_FULL_SCREEN_ENTER)\n    );\n    const hasFocusableElements = focusableElements.length > 0;\n\n    // We need to handle five cases:\n    // 1. The card has no focusable elements --> focus the anchor\n    // 2. Focus is on the card container (do nothing, natural tab order)\n    // 3. Focus is on the anchor and the user pressed Tab + Shift (backwards)\n    //    -> Move to the last focusable element (end of card)\n    // 4. Focus is on the last focusable element and the user pressed Tab\n    //    (forwards) -> Move to the anchor (top of card)\n    // 5. otherwise we don't interfere\n\n    if (!hasFocusableElements) {\n      // case 1\n      stopEvent();\n      this.overlay.anchor.focus();\n      return;\n    }\n\n    // case 2\n    if (isFocusedContainer) return;\n\n    const lastFocusable = focusableElements[focusableElements.length - 1];\n    const isFocusedLast = event.target === lastFocusable;\n\n    if (isFocusedAnchor && event.shiftKey) {\n      stopEvent();\n      lastFocusable.focus();\n      return;\n    }\n\n    if (isFocusedLast && !event.shiftKey) {\n      stopEvent();\n      this.overlay.anchor.focus();\n      return;\n    }\n  }\n\n  /**\n   * Creates the full screen overlay.\n   * @private\n   * @returns {CardFullScreenOverlay}\n   */\n  private _createOverlay(): CardFullScreenOverlay {\n    const container = document.createElement(\"div\");\n    container.id = Card.attr.ID_FULL_SCREEN_OVERLAY;\n    container.onclick = this.exitFullScreen.bind(this);\n\n    const anchor = this._createOverlayCloseAnchor();\n    container.appendChild(anchor);\n\n    return { container, anchor };\n  }\n\n  /**\n   * Creates the anchor element used to exit the full screen mode.\n   * @private\n   * @returns {HTMLAnchorElement}\n   */\n  private _createOverlayCloseAnchor(): HTMLAnchorElement {\n    const anchor = document.createElement(\"a\");\n    anchor.classList.add(Card.attr.CLASS_FULL_SCREEN_EXIT);\n    anchor.tabIndex = 0;\n    anchor.onclick = () => this.exitFullScreen();\n    anchor.onkeydown = (ev) => {\n      if (ev.key === \"Enter\" || ev.key === \" \") {\n        this.exitFullScreen();\n      }\n    };\n    anchor.innerHTML = this._overlayCloseHtml();\n\n    return anchor;\n  }\n\n  /**\n   * Returns the HTML for the close icon.\n   * @private\n   * @returns {string}\n   */\n  private _overlayCloseHtml(): string {\n    return (\n      \"Close \" +\n      \"<svg width='20' height='20' fill='currentColor' class='bi bi-x-lg' \" +\n      \"viewBox='0 0 16 16'>\" +\n      \"<path d='M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 \" +\n      \"0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 \" +\n      \"5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z'/></svg>\"\n    );\n  }\n\n  /**\n   * The registry of card instances and their associated DOM elements.\n   * @private\n   * @static\n   * @type {WeakMap<HTMLElement, Card>}\n   */\n  private static instanceMap: WeakMap<HTMLElement, Card> = new WeakMap();\n\n  /**\n   * Returns the card instance associated with the given element, if any.\n   * @public\n   * @static\n   * @param {HTMLElement} el\n   * @returns {(Card | undefined)}\n   */\n  public static getInstance(el: HTMLElement): Card | undefined {\n    return Card.instanceMap.get(el);\n  }\n\n  /**\n   * If cards are initialized before the DOM is ready, we re-schedule the\n   * initialization to occur on DOMContentLoaded.\n   * @private\n   * @static\n   * @type {boolean}\n   */\n  private static onReadyScheduled = false;\n\n  /**\n   * Initializes all cards that require initialization on the page, or schedules\n   * initialization if the DOM is not yet ready.\n   * @public\n   * @static\n   * @param {boolean} [flushResizeObserver=true]\n   */\n  public static initializeAllCards(flushResizeObserver = true): void {\n    if (document.readyState === \"loading\") {\n      if (!Card.onReadyScheduled) {\n        Card.onReadyScheduled = true;\n        document.addEventListener(\"DOMContentLoaded\", () => {\n          Card.initializeAllCards(false);\n        });\n      }\n      return;\n    }\n\n    if (flushResizeObserver) {\n      // Trigger a recheck of observed cards to unobserve non-existent cards\n      Card.shinyResizeObserver.flush();\n    }\n\n    const initSelector = `.${Card.attr.CLASS_CARD}[${Card.attr.ATTR_INIT}]`;\n    if (!document.querySelector(initSelector)) {\n      // no cards to initialize\n      return;\n    }\n\n    const cards = document.querySelectorAll(initSelector);\n    cards.forEach((card) => new Card(card as HTMLElement));\n  }\n}\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Card = Card;\n\nexport { Card };\n", "import { InputBinding, registerBinding } from \"./_utils\";\nimport { ShinyResizeObserver } from \"./_shinyResizeObserver\";\n\n/**\n * Methods for programmatically toggling the state of the sidebar. These methods\n * describe the desired state of the sidebar: `\"close\"` and `\"open\"` transition\n * the sidebar to the desired state, unless the sidebar is already in that\n * state. `\"toggle\"` transitions the sidebar to the state opposite of its\n * current state.\n * @typedef {SidebarToggleMethod}\n */\ntype SidebarToggleMethod = \"close\" | \"open\" | \"toggle\";\n\n/**\n * Data received by the input binding's `receiveMessage` method.\n * @typedef {SidebarMessageData}\n */\ntype SidebarMessageData = {\n  method: SidebarToggleMethod;\n};\n\n/**\n * The DOM elements that make up the sidebar. `main`, `sidebar`, and `toggle`\n * are all direct children of `container` (in that order).\n * @interface SidebarComponents\n * @typedef {SidebarComponents}\n */\ninterface SidebarComponents {\n  /**\n   * The `layout_sidebar()` parent container, with class\n   * `Sidebar.classes.LAYOUT`.\n   * @type {HTMLElement}\n   */\n  container: HTMLElement;\n  /**\n   * The main content area of the sidebar layout.\n   * @type {HTMLElement}\n   */\n  main: HTMLElement;\n  /**\n   * The sidebar container of the sidebar layout.\n   * @type {HTMLElement}\n   */\n  sidebar: HTMLElement;\n  /**\n   * The toggle button that is used to toggle the sidebar state.\n   * @type {HTMLElement}\n   */\n  toggle: HTMLElement;\n}\n\n/**\n * The bslib sidebar component class. This class is only used for collapsible\n * sidebars.\n *\n * @class Sidebar\n * @typedef {Sidebar}\n */\nclass Sidebar {\n  /**\n   * The DOM elements that make up the sidebar, see `SidebarComponents`.\n   * @private\n   * @type {SidebarComponents}\n   */\n  private layout: SidebarComponents;\n\n  /**\n   * A Shiny-specific resize observer that ensures Shiny outputs in the main\n   * content areas of the sidebar resize appropriately.\n   * @private\n   * @type {ShinyResizeObserver}\n   * @static\n   */\n  private static shinyResizeObserver = new ShinyResizeObserver();\n\n  /**\n   * Creates an instance of a collapsible bslib Sidebar.\n   * @constructor\n   * @param {HTMLElement} container\n   */\n  constructor(container: HTMLElement) {\n    Sidebar.instanceMap.set(container, this);\n    this.layout = {\n      container,\n      main: container.querySelector(\":scope > .main\") as HTMLElement,\n      sidebar: container.querySelector(\":scope > .sidebar\") as HTMLElement,\n      toggle: container.querySelector(\n        \":scope > .collapse-toggle\"\n      ) as HTMLElement,\n    } as SidebarComponents;\n\n    const sideAccordion = this.layout.sidebar.querySelector(\n      \":scope > .sidebar-content > .accordion\"\n    );\n    if (sideAccordion) {\n      // Add `.has-accordion` class to `.sidebar-content` container\n      sideAccordion?.parentElement?.classList.add(\"has-accordion\");\n      sideAccordion.classList.add(\"accordion-flush\");\n    }\n\n    if (this.layout.toggle) {\n      this._initEventListeners();\n      this._initSidebarCounters();\n      this._initDesktop();\n    }\n\n    // Start watching the main content area for size changes to ensure Shiny\n    // outputs resize appropriately during sidebar transitions.\n    Sidebar.shinyResizeObserver.observe(this.layout.main);\n\n    container.removeAttribute(\"data-bslib-sidebar-init\");\n    const initScript = container.querySelector(\n      \":scope > script[data-bslib-sidebar-init]\"\n    );\n    if (initScript) {\n      container.removeChild(initScript);\n    }\n  }\n\n  /**\n   * Read the current state of the sidebar. Note that, when calling this method,\n   * the sidebar may be transitioning into the state returned by this method.\n   *\n   * @description\n   * The sidebar state works as follows, starting from the open state. When the\n   * sidebar is closed:\n   * 1. We add both the `COLLAPSE` and `TRANSITIONING` classes to the sidebar.\n   * 2. The sidebar collapse begins to animate. On desktop devices, and where it\n   *    is supported, we transition the `grid-template-columns` property of the\n   *    sidebar layout. On mobile, the sidebar is hidden immediately. In both\n   *    cases, the collapse icon rotates and we use this rotation to determine\n   *    when the transition is complete.\n   * 3. If another sidebar state toggle is requested while closing the sidebar,\n   *    we remove the `COLLAPSE` class and the animation immediately starts to\n   *    reverse.\n   * 4. When the `transition` is complete, we remove the `TRANSITIONING` class.\n   * @readonly\n   * @type {boolean}\n   */\n  get isClosed(): boolean {\n    return this.layout.container.classList.contains(Sidebar.classes.COLLAPSE);\n  }\n\n  /**\n   * Static classes related to the sidebar layout or state.\n   * @public\n   * @static\n   * @readonly\n   * @type {{ LAYOUT: string; COLLAPSE: string; TRANSITIONING: string; }}\n   */\n  public static readonly classes = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LAYOUT: \"bslib-sidebar-layout\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    COLLAPSE: \"sidebar-collapsed\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    TRANSITIONING: \"transitioning\",\n  };\n\n  /**\n   * If sidebars are initialized before the DOM is ready, we re-schedule the\n   * initialization to occur on DOMContentLoaded.\n   * @private\n   * @static\n   * @type {boolean}\n   */\n  private static onReadyScheduled = false;\n  /**\n   * A map of initialized sidebars to their respective Sidebar instances.\n   * @private\n   * @static\n   * @type {WeakMap<HTMLElement, Sidebar>}\n   */\n  private static instanceMap: WeakMap<HTMLElement, Sidebar> = new WeakMap();\n\n  /**\n   * Given a sidebar container, return the Sidebar instance associated with it.\n   * @public\n   * @static\n   * @param {HTMLElement} el\n   * @returns {(Sidebar | undefined)}\n   */\n  public static getInstance(el: HTMLElement): Sidebar | undefined {\n    return Sidebar.instanceMap.get(el);\n  }\n\n  /**\n   * Initialize all collapsible sidebars on the page.\n   * @public\n   * @static\n   * @param {boolean} [flushResizeObserver=true] When `true`, we remove\n   * non-existent elements from the ResizeObserver. This is required\n   * periodically to prevent memory leaks. To avoid over-checking, we only flush\n   * the ResizeObserver when initializing sidebars after page load.\n   */\n  public static initCollapsibleAll(flushResizeObserver = true): void {\n    if (document.readyState === \"loading\") {\n      if (!Sidebar.onReadyScheduled) {\n        Sidebar.onReadyScheduled = true;\n        document.addEventListener(\"DOMContentLoaded\", () => {\n          Sidebar.initCollapsibleAll(false);\n        });\n      }\n      return;\n    }\n\n    const initSelector = `.${Sidebar.classes.LAYOUT}[data-bslib-sidebar-init]`;\n    if (!document.querySelector(initSelector)) {\n      // no sidebars to initialize\n      return;\n    }\n\n    if (flushResizeObserver) Sidebar.shinyResizeObserver.flush();\n\n    const containers = document.querySelectorAll(initSelector);\n    containers.forEach((container) => new Sidebar(container as HTMLElement));\n  }\n\n  /**\n   * Initialize event listeners for the sidebar toggle button.\n   * @private\n   */\n  private _initEventListeners(): void {\n    const { toggle } = this.layout;\n\n    toggle.addEventListener(\"click\", (ev) => {\n      ev.preventDefault();\n      this.toggle(\"toggle\");\n    });\n\n    // Remove the transitioning class when the transition ends. We watch the\n    // collapse toggle icon because it's guaranteed to transition, whereas the\n    // sidebar doesn't animate on mobile (or in browsers where animating\n    // grid-template-columns is not supported).\n    toggle\n      .querySelector(\".collapse-icon\")\n      ?.addEventListener(\"transitionend\", () => this._finalizeState());\n  }\n\n  /**\n   * Initialize nested sidebar counters.\n   *\n   * @description\n   * This function walks up the DOM tree, adding CSS variables to each direct\n   * parent sidebar layout that count the layout's position in the stack of\n   * nested layouts. We use these counters to keep the collapse toggles from\n   * overlapping. Note that always-open sidebars that don't have collapse\n   * toggles break the chain of nesting.\n   * @private\n   */\n  private _initSidebarCounters(): void {\n    const { container } = this.layout;\n\n    const selectorChildLayouts =\n      `.${Sidebar.classes.LAYOUT}` +\n      \"> .main > \" +\n      `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`;\n\n    const isInnermostLayout =\n      container.querySelector(selectorChildLayouts) === null;\n\n    if (!isInnermostLayout) {\n      // There are sidebar layouts nested within this layout; defer to children\n      return;\n    }\n\n    function nextSidebarParent(el: HTMLElement | null): HTMLElement | null {\n      el = el ? el.parentElement : null;\n      if (el && el.classList.contains(\"main\")) {\n        // .bslib-sidebar-layout > .main > .bslib-sidebar-layout\n        el = el.parentElement;\n      }\n      if (el && el.classList.contains(Sidebar.classes.LAYOUT)) {\n        return el;\n      }\n      return null;\n    }\n\n    const layouts = [container];\n    let parent = nextSidebarParent(container);\n\n    while (parent) {\n      // Add parent to front of layouts array, so we sort outer -> inner\n      layouts.unshift(parent);\n      parent = nextSidebarParent(parent);\n    }\n\n    const count = { left: 0, right: 0 };\n    layouts.forEach(function (x: HTMLElement, i: number): void {\n      x.style.setProperty(\"--bslib-sidebar-counter\", i.toString());\n      const isRight = x.classList.contains(\"sidebar-right\");\n      const thisCount = isRight ? count.right++ : count.left++;\n      x.style.setProperty(\n        \"--bslib-sidebar-overlap-counter\",\n        thisCount.toString()\n      );\n    });\n  }\n\n  /**\n   * Initialize the sidebar's initial state when `open = \"desktop\"`.\n   * @private\n   */\n  private _initDesktop(): void {\n    const { container } = this.layout;\n    // If sidebar is marked open='desktop'...\n    if (container.dataset.bslibSidebarOpen?.trim() !== \"desktop\") {\n      return;\n    }\n\n    // then close sidebar on mobile\n    const initCollapsed = window\n      .getComputedStyle(container)\n      .getPropertyValue(\"--bslib-sidebar-js-init-collapsed\");\n\n    if (initCollapsed.trim() === \"true\") {\n      this.toggle(\"close\");\n    }\n  }\n\n  /**\n   * Toggle the sidebar's open/closed state.\n   * @public\n   * @param {SidebarToggleMethod | undefined} method Whether to `\"open\"`,\n   * `\"close\"` or `\"toggle\"` the sidebar. If `.toggle()` is called without an\n   * argument, it will toggle the sidebar's state.\n   */\n  public toggle(method: SidebarToggleMethod | undefined): void {\n    if (typeof method === \"undefined\") {\n      method = \"toggle\";\n    }\n\n    const { container, sidebar } = this.layout;\n    const isClosed = this.isClosed;\n\n    if ([\"open\", \"close\", \"toggle\"].indexOf(method) === -1) {\n      throw new Error(`Unknown method ${method}`);\n    }\n\n    if (method === \"toggle\") {\n      method = isClosed ? \"open\" : \"close\";\n    }\n\n    if ((isClosed && method === \"close\") || (!isClosed && method === \"open\")) {\n      // nothing to do, sidebar is already in the desired state\n      return;\n    }\n\n    if (method === \"open\") {\n      // unhide sidebar immediately when opening,\n      // otherwise the sidebar is hidden on transitionend\n      sidebar.hidden = false;\n    }\n\n    // Add a transitioning class just before adding COLLAPSE_CLASS since we want\n    // some of the transitioning styles to apply before the collapse state\n    container.classList.add(Sidebar.classes.TRANSITIONING);\n    container.classList.toggle(Sidebar.classes.COLLAPSE);\n  }\n\n  /**\n   * When the sidebar open/close transition ends, finalize the sidebar's state.\n   * @private\n   */\n  private _finalizeState(): void {\n    const { container, sidebar, toggle } = this.layout;\n    container.classList.remove(Sidebar.classes.TRANSITIONING);\n    sidebar.hidden = this.isClosed;\n    toggle.setAttribute(\"aria-expanded\", this.isClosed ? \"false\" : \"true\");\n\n    // Send browser-native event with updated sidebar state\n    const event = new CustomEvent(\"bslib.sidebar\", {\n      bubbles: true,\n      detail: { open: !this.isClosed },\n    });\n    sidebar.dispatchEvent(event);\n\n    // Trigger Shiny input and output binding events\n    $(sidebar).trigger(\"toggleCollapse.sidebarInputBinding\");\n    $(sidebar).trigger(this.isClosed ? \"hidden\" : \"shown\");\n  }\n}\n\n/**\n * A Shiny input binding for a sidebar.\n * @class SidebarInputBinding\n * @typedef {SidebarInputBinding}\n * @extends {InputBinding}\n */\nclass SidebarInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(`.${Sidebar.classes.LAYOUT} > .bslib-sidebar-input`);\n  }\n\n  getValue(el: HTMLElement): boolean {\n    const sb = Sidebar.getInstance(el.parentElement as HTMLElement);\n    if (!sb) return false;\n    return !sb.isClosed;\n  }\n\n  setValue(el: HTMLElement, value: boolean): void {\n    const method = value ? \"open\" : \"close\";\n    this.receiveMessage(el, { method });\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"toggleCollapse.sidebarInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".sidebarInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: SidebarMessageData) {\n    const sb = Sidebar.getInstance(el.parentElement as HTMLElement);\n    if (sb) sb.toggle(data.method);\n  }\n}\n\nregisterBinding(SidebarInputBinding, \"sidebar\");\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Sidebar = Sidebar;\n", "import type { Handler as ShinyCustomMessageHandler } from \"rstudio-shiny/srcts/types/src/shiny/shinyapp\";\n\nexport function shinyAddCustomMessageHandlers(handlers: {\n  [key: string]: ShinyCustomMessageHandler;\n}): void {\n  if (!window.Shiny) {\n    return;\n  }\n\n  for (const [name, handler] of Object.entries(handlers)) {\n    Shiny.addCustomMessageHandler(name, handler);\n  }\n}\n", "// ----------------------------------------------------------------------------\n// First, bring in non-webcomponent (legacy) components (they attach to the window)\n// ----------------------------------------------------------------------------\nimport \"./accordion\";\nimport \"./card\";\nimport \"./sidebar\";\n\n// ----------------------------------------------------------------------------\n// Register custom message handlers for Shiny\n// ----------------------------------------------------------------------------\nimport { InputBinding } from \"./_utils\";\nimport { shinyAddCustomMessageHandlers } from \"./_shinyAddCustomMessageHandlers\";\n\nconst bslibMessageHandlers = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  \"bslib.toggle-input-binary\": (msg: any) => {\n    // This handler was written for `toggle_switch()`, but could be used for any\n    // binary Shiny input, e.g. checkbox.\n    const el = document.getElementById(msg.id) as HTMLElement;\n    if (!el) {\n      console.warn(\"[bslib.toggle-input-binary] No element found\", msg);\n    }\n\n    const binding = $(el).data(\"shiny-input-binding\");\n    if (!(binding instanceof InputBinding)) {\n      console.warn(\"[bslib.toggle-input-binary] No input binding found\", msg);\n      return;\n    }\n\n    let value = msg.value;\n    if (typeof value === \"undefined\") {\n      value = !binding.getValue(el);\n    }\n    binding.receiveMessage(el, { value });\n  },\n};\n\nif (window.Shiny) {\n  shinyAddCustomMessageHandlers(bslibMessageHandlers);\n}\n\n// ----------------------------------------------------------------------\n// Append the (global) SVG linearGradient to the body.\n// value_box() uses this (i.e., bslib---icon-gradient element) to apply a\n// gradient to the icon when bs_theme(preset=\"shiny\").\n// ----------------------------------------------------------------------\n\nfunction insertSvgGradient() {\n  const temp = document.createElement(\"div\");\n  temp.innerHTML = `\n  <svg aria-hidden=\"true\" focusable=\"false\" style=\"width:0;height:0;position:absolute;\">\n    <!-- ref: https://fvsch.com/svg-gradient-fill -->\n    <linearGradient id='bslib---icon-gradient' x1='0' y1='0' x2='1.6' y2='2.4'>\n      <stop offset='0%' stop-color='var(--bslib-icon-gradient-0, #007bc2)' />\n      <stop offset='14.29%' stop-color='var(--bslib-icon-gradient-1, #0770c9)' />\n      <stop offset='28.57%' stop-color='var(--bslib-icon-gradient-2, #0d63da)' />\n      <stop offset='42.86%' stop-color='var(--bslib-icon-gradient-3, #2b4af9)' />\n      <stop offset='57.14%' stop-color='var(--bslib-icon-gradient-4, #5e29f7)' />\n      <stop offset='71.43%' stop-color='var(--bslib-icon-gradient-5, #7217d7)' />\n      <stop offset='100%' stop-color='var(--bslib-icon-gradient-6, #74149c)' />\n    </linearGradient>\n  </svg>`;\n  document.body.appendChild(temp.children[0] as Node);\n}\n\nif (document.readyState === \"complete\") {\n  insertSvgGradient();\n} else {\n  document.addEventListener(\"DOMContentLoaded\", insertSvgGradient);\n}\n"],
  "mappings": "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",
  "names": []
}
